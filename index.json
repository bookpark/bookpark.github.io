[{"content":"JPA를 사용하며 쿼리 로그를 출력해야 할 때의 설정은 다음과 같다.\napplication.yml\n1 2 3 4 5 6 7 8 9 10 spring: jpa: properties: hibernate: show_sql: true format_sql: true logging: level: org.hibernate.sql: debug org.hibernate.type: trace # parameter 값 보기 show_sql 옵션은 System.out 에 Hibernate 실행 SQL을 남기고,\norg.hibernate.sql 옵션은 logger를 통해 Hibernate 실행 SQL을 남긴다.\n가급적 쿼리 출력은 로거를 통해 남기자!\n위 설정으로 parameter 값을 볼 수 있지만 쿼리문 안에 parameter 값이 적용되어있지 않아 보기 불편할 수 있다.\n이 때 p6spy를 적용해 쿼리 로그를 확인해보자.\nbuild.gradle\n1 2 3 4 dependencies { // p6spy implementation \u0026#39;com.github.gavlyukovskiy:p6spy-spring-boot-starter:1.9.0\u0026#39; } application.yml\n1 2 3 4 5 6 7 decorator: datasource: # p6spy 설정 적용 p6spy: enable-logging: true multiline: true logging: slf4j p6spy 설정을 통해 log 파일을 남기거나 log 포맷을 바꾸는 등 여러 설정을 할 수 있다.\n2023년 3월 8일 기준 SpringBoot 3.0 이상에서도 잘 작동한다.\n참고: https://github.com/gavlyukovskiy/spring-boot-data-source-decorator\np6spy가 적용 된 로그를 확인해보자.\n1 2 3 4 2023-03-08T23:59:58.355+09:00 INFO 51289 --- [ main] p6spy insert into member (username, id) values (?, ?) insert into member (username, id) values (\u0026#39;member\u0026#39;, 1); 2023-03-08T23:59:58.356+09:00 INFO 51289 --- [ main] p6spy 바인딩 된 parameter 값이 쿼리 문 안에 잘 적용된 모습이다.\n","permalink":"https://bookpark.github.io/posts/2023-03-08-jpa-logging-p6spy/","summary":"JPA를 사용하며 쿼리 로그를 출력해야 할 때의 설정은 다음과 같다.\napplication.yml\n1 2 3 4 5 6 7 8 9 10 spring: jpa: properties: hibernate: show_sql: true format_sql: true logging: level: org.hibernate.sql: debug org.hibernate.type: trace # parameter 값 보기 show_sql 옵션은 System.out 에 Hibernate 실행 SQL을 남기고,\norg.hibernate.sql 옵션은 logger를 통해 Hibernate 실행 SQL을 남긴다.\n가급적 쿼리 출력은 로거를 통해 남기자!\n위 설정으로 parameter 값을 볼 수 있지만 쿼리문 안에 parameter 값이 적용되어있지 않아 보기 불편할 수 있다.","title":"[JPA] 쿼리 로그 설정"},{"content":"API 성능 최적화 하기 1편에서 이어지는 내용입니다.\n첫번째로 엔티티를 직접 노출하여 멤버의 팀명을 호출하는 API를 만들어보았다.\nMemberController.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @RestController @RequiredArgsConstructor public class MemberController { private final MemberJpaRepository memberJpaRepository; @GetMapping(\u0026#34;/api/v1/members\u0026#34;) public List\u0026lt;Member\u0026gt; membersV1() { List\u0026lt;Member\u0026gt; all = memberJpaRepository.findAll(); for (Member member : all) { member.getTeam().getName(); // Lazy 강제 초기화 } return all; } } 아무런 설정을 하지 않고 이대로 API를 호출해보면 다음과 같은 오류 메시지가 나올것이다.\n1 com.fasterxml.jackson.databind.exc.InvalidDefinitionException: No serializer found for class org.hibernate.proxy.pojo.bytebuddy.ByteBuddyInterceptor and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS) (through reference chain: java.util.ArrayList[0]-\u0026gt;study.datajpa.entity.Member[\u0026#34;team\u0026#34;]-\u0026gt;study.datajpa.entity.Team$HibernateProxy$AecgE8ot[\u0026#34;hibernateLazyInitializer\u0026#34;]) 현재 엔티티의 설계는 기본적으로 지연 로딩으로 되어있다. 이는 실제 엔티티 대신에 프록시가 존재한다는 말이 된다.\n기본 jackson 라이브러리는 기본적으로 이 프록시 객체를 json으로 어떻게 생성해야 하는지 모르기 때문에 Hibernate5Module 을 스프링 빈으로 등록하여 해결해야한다.\nHibernate5Module 등록\n스프링 3.0 이상 기준\nbuild.gradle\n1 2 3 4 dependencies { // Hibernate5Module implementation \u0026#39;com.fasterxml.jackson.datatype:jackson-datatype-hibernate5-jakarta\u0026#39; } \u0026lt;프로젝트명\u0026gt;Application.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 기본적으로 초기화 된 프록시 객체만 노출 @Bean Hibernate5JakartaModule hibernate5Module() { return new Hibernate5JakartaModule(); } // 강제 지연 로딩 설정을 하기 위해서는 이와 같이 추가해주면 된다. @Bean Hibernate5JakartaModule hibernate5JakartaModule() { Hibernate5JakartaModule hibernate5JakartaModule = new Hibernate5JakartaModule(); hibernate5JakartaModule.configure(Hibernate5JakartaModule.Feature.FORCE_LAZY_LOADING, true); return hibernate5JakartaModule; } FORCE_LAZY_LOADING을 키게 됐을 때 양방향 연관관계를 계속 로딩하게 되기 때문에 관계 한 곳에 @JsonIgnore 옵션을 주어야 한다. 그렇지 않으면 무한 루프가 걸리게 된다.\n간단한 프로젝트같은 경우에는 직접 엔티티를 노출하며 Hibernate5Module을 사용해도 무방하겠지만 대부분의 경우에는 DTO를 이용하여 값을 반환해주는 것이 좋은 방법이다.\n엔티티를 DTO로 변환\nMemberController.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @GetMapping(\u0026#34;api/v2/members\u0026#34;) public List\u0026lt;MemberDto\u0026gt; membersV2() { List\u0026lt;Member\u0026gt; members = memberJpaRepository.findAll(); return members.stream() .map(MemberDto::new) .collect(Collectors.toList()); } @Data static class MemberDto { private Long memberId; private String username; private int age; private String teamName; public MemberDto(Member member) { memberId = member.getId(); username = member.getUsername(); age = member.getAge(); teamName = member.getTeam().getName(); } } 참고로 현재 더미 데이터로 member1부터 member4 그리고 teamA, teamB를 가지고 있다.\nmember1과 member2는 teamA에 속하고 member3과 member4는 teamB에 속한 상태이다.\n다음은 엔티티를 DTO로만 변환해 호출했을 때의 쿼리 결과이다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 Hibernate: select m1_0.member_id, m1_0.age, m1_0.team_id, m1_0.username from member m1_0 2023-03-10T20:31:06.936+09:00 INFO 61090 --- [nio-8080-exec-3] p6spy : #1678447866936 | took 0ms | statement | connection 3| url jdbc:mysql://localhost:3306/datajpa?useSSL=false\u0026amp;useUnicode=true\u0026amp;serverTimezone=Asia/Seoul select m1_0.member_id,m1_0.age,m1_0.team_id,m1_0.username from member m1_0 select m1_0.member_id,m1_0.age,m1_0.team_id,m1_0.username from member m1_0; Hibernate: select t1_0.team_id, t1_0.name from team t1_0 where t1_0.team_id=? 2023-03-10T20:31:06.959+09:00 INFO 61090 --- [nio-8080-exec-3] p6spy : #1678447866959 | took 19ms | statement | connection 3| url jdbc:mysql://localhost:3306/datajpa?useSSL=false\u0026amp;useUnicode=true\u0026amp;serverTimezone=Asia/Seoul select t1_0.team_id,t1_0.name from team t1_0 where t1_0.team_id=? select t1_0.team_id,t1_0.name from team t1_0 where t1_0.team_id=1; Hibernate: select t1_0.team_id, t1_0.name from team t1_0 where t1_0.team_id=? 2023-03-10T20:31:06.963+09:00 INFO 61090 --- [nio-8080-exec-3] p6spy : #1678447866963 | took 0ms | statement | connection 3| url jdbc:mysql://localhost:3306/datajpa?useSSL=false\u0026amp;useUnicode=true\u0026amp;serverTimezone=Asia/Seoul select t1_0.team_id,t1_0.name from team t1_0 where t1_0.team_id=? select t1_0.team_id,t1_0.name from team t1_0 where t1_0.team_id=2; N+1 문제를 일으키며 쿼리가 총 세번 실행된 모습을 볼수있다.\nmember조회 한 번 member → team 지연 로딩 조회 N번 teamA와 teamB가 있으므로 2번 조회되므로 1+2 총 세번 실행되었다. 이 문제를 해결하기 위해 이제 Fetch Join을 적용해 최적화 해보도록 하겠다.\nFetch Join 최적화\nMemberController.java\n1 2 3 4 5 6 7 @GetMapping(\u0026#34;/api/v3/members\u0026#34;) public List\u0026lt;MemberDto\u0026gt; membersV3() { List\u0026lt;Member\u0026gt; members = memberJpaRepository.findAllMemberWithTeam(); return members.stream() .map(MemberDto::new) .collect(Collectors.toList()); } MemberJpaRepository.java\n1 2 3 4 5 6 public List\u0026lt;Member\u0026gt; findAllMemberWithTeam() { return em.createQuery( \u0026#34;select m from Member m\u0026#34; + \u0026#34; join fetch m.team t\u0026#34;, Member.class) .getResultList(); } 해당 API를 호출했을 때 조회되는 쿼리의 개수를 보자.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Hibernate: select m1_0.member_id, m1_0.age, t1_0.team_id, t1_0.name, m1_0.username from member m1_0 join team t1_0 on t1_0.team_id=m1_0.team_id 2023-03-10T20:49:54.983+09:00 INFO 61178 --- [nio-8080-exec-3] p6spy : #1678448994983 | took 0ms | statement | connection 3| url jdbc:mysql://localhost:3306/datajpa?useSSL=false\u0026amp;useUnicode=true\u0026amp;serverTimezone=Asia/Seoul select m1_0.member_id,m1_0.age,t1_0.team_id,t1_0.name,m1_0.username from member m1_0 join team t1_0 on t1_0.team_id=m1_0.team_id select m1_0.member_id,m1_0.age,t1_0.team_id,t1_0.name,m1_0.username from member m1_0 join team t1_0 on t1_0.team_id=m1_0.team_id; Fetch Join으로 인해 member → team 은 이미 조회 된 상태이므로 지연로딩이 일어나지 않아 쿼리 한 번에 모두 조회한 모습을 볼 수 있다.\n이로서 X to One 연관 관계에서 API 개발할 시에 마주할 수 있는 문제와 최적화 방법을 알아보았다. 다음 글에서는 X to Many 연관 관계에서의 API 개발 및 최적화에 관해 알아보겠다.\n","permalink":"https://bookpark.github.io/posts/2023-02-05-jpa-api-optimization-2/","summary":"API 성능 최적화 하기 1편에서 이어지는 내용입니다.\n첫번째로 엔티티를 직접 노출하여 멤버의 팀명을 호출하는 API를 만들어보았다.\nMemberController.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @RestController @RequiredArgsConstructor public class MemberController { private final MemberJpaRepository memberJpaRepository; @GetMapping(\u0026#34;/api/v1/members\u0026#34;) public List\u0026lt;Member\u0026gt; membersV1() { List\u0026lt;Member\u0026gt; all = memberJpaRepository.findAll(); for (Member member : all) { member.getTeam().getName(); // Lazy 강제 초기화 } return all; } } 아무런 설정을 하지 않고 이대로 API를 호출해보면 다음과 같은 오류 메시지가 나올것이다.","title":"[JPA] API 성능 최적화 하기 (2) - Fetch Join"},{"content":"X to One 연관 관계의 성능 최적화를 하기위해 먼저 알아야 할 것은 즉시(Eager) 로딩과 지연(Lazy) 로딩의 차이이다.\nMember.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Entity @Getter @Setter public class Member { @Id @GeneratedValue private Long id; private String name; @ManyToOne(fetch = FetchType.EAGER) private Team team; } Team.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Entity @Getter @Setter public class Team { @Id @GeneratedValue private Long id; private String name; @OneToMany(mappedBy = \u0026#34;team\u0026#34;) private List\u0026lt;Member\u0026gt; members = new ArrayList\u0026lt;\u0026gt;(); } 간단하게 두 엔티티의 연관 관계를 만들어주고, FetchType.EAGER로 설정을 해두었다.\n간단한 엔티티 테스트 코드를 통해 쿼리문을 확인해보도록 하자.\nMemberTest.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @SpringBootTest @Transactional class MemberTest { @PersistenceContext EntityManager em; @Test public void testEntity() { Team teamA = new Team(\u0026#34;teamA\u0026#34;); em.persist(teamA); Member member1 = new Member(\u0026#34;member1\u0026#34;, 10, teamA); em.persist(member1); // 초기화 em.flush(); em.clear(); // 확인 em.find(Member.class, member1.getId()); } } 결과\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 Hibernate: select m1_0.member_id, m1_0.age, t1_0.team_id, t1_0.name, m1_0.username from member m1_0 left join team t1_0 on t1_0.team_id=m1_0.team_id where m1_0.member_id=? FetchType.EAGER 로 설정되어 있을 때는 이와 같이 member만 조회했음에도 team까지 함께 join되어 결과 값을 가져온다.\n다음은 FetchType.LAZY 로 설정했을 때의 결과 값이다.\n결과\n1 2 3 4 5 6 7 8 9 10 Hibernate: select m1_0.member_id, m1_0.age, m1_0.team_id, m1_0.username from member m1_0 where m1_0.member_id=? FetchType.LAZY 로 설정되어 있을 때는 team까지는 가져오지 않고 조회한 member만 가져오게 된다.\nJPA에서 X to One 연관 관계의 기본 값은 FetchType.EAGER 로 설정되어 있다. 이로 인해 필요치 않은 데이터가 같이 조회되며 N+1 문제를 일으킬 수 있다.\n지연 로딩을 피하기 위해 FetchType.EAGER 로 설정하는 것은 성능 튜닝을 어렵게 만드는 지름길이다.\n성능 최적화가 필요한 경우에는 Fetch Join 을 사용하면 된다. 다음 편에서는 이 fetch join을 사용하여 성능 최적화하는 방법을 알아보도록 하자.\n","permalink":"https://bookpark.github.io/posts/2023-02-04-jpa-api-optimization/","summary":"X to One 연관 관계의 성능 최적화를 하기위해 먼저 알아야 할 것은 즉시(Eager) 로딩과 지연(Lazy) 로딩의 차이이다.\nMember.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Entity @Getter @Setter public class Member { @Id @GeneratedValue private Long id; private String name; @ManyToOne(fetch = FetchType.EAGER) private Team team; } Team.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Entity @Getter @Setter public class Team { @Id @GeneratedValue private Long id; private String name; @OneToMany(mappedBy = \u0026#34;team\u0026#34;) private List\u0026lt;Member\u0026gt; members = new ArrayList\u0026lt;\u0026gt;(); } 간단하게 두 엔티티의 연관 관계를 만들어주고, FetchType.","title":"[JPA] API 성능 최적화 하기 (1) - X to One 연관 관계"}]