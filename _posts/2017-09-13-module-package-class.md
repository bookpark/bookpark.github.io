---
layout: post
title:  "모듈, 패키지, 클래스"
categories: python
date: 2017-09-13
---

## 모듈

### 모듈 불러오기

`import`

### __name__변수

파이썬 인터프리터를 이용해 실행한 코드인지를 확인하여 단순히 `import`한 모듈의 경우 실행을 막는 방식을 사용할 수 있다.

각 모듈은 자신의 이름을 가지며, 모듈 이름은 모듈의 전역변수 `__name__`에서 확인 할 수 있다.

### from을 사용해 모듈의 함수를 직접 import

`import` 모듈명의 경우, 모듈의 이름이 전역 네임스페이스에 등록되어 `모듈명.함수`로 사용가능하다.

모듈명을 생략하고 모듈 내부의 함수를 쓰고 싶다면, `from 모듈명 import 함수명`으로 불러들일 수 있다.

### from 모듈명 * 을 사용해 모듈 내 모든 식별자 (변수, 함수) import

### as로 별칭 할당

`from 모듈명 import` 또는 `import 모듈명`에서, 같은 모듈명이 존재하거나 혼동 될 수 있을 경우, 뒤에 `as`를 붙여 사용할 모듈명을 변경할 수 있다.

## 패키지

패키지는 모듈들을 모아 둔 특별한 폴더를 뜻한다.

### *, _\_all\_\_

패키지에 포함된 하위 패키지 및 모듈을 불러올 때, *을 사용하면 해당 모듈의 모든 식별자들을 불러온다.

이 때, 각 모듈에서 자신이 import될 때 불러와질 목록을 지정하고자 한다면 `__all__` 을 정의하면 된다.

# 클래스

## 객체지향 프로그래밍

파이썬의 모든것은 객체이며, 객체를 사용할 때는 변수에 해당 객체를 참조(Reference)시켜 사용한다.
객체는 변수와 함수를 가지며, 특별히 객체가 가진 **변수**와 **함수**는 각각 **속성(attribute)**과 **메서드(method)**라고 부른다.

객체는 어떠한 타입, 즉 특정한 **클래스**의 형태를 가진 **인스턴스**를 나타낸다.

### 클래스

```python
class Shop:
    def __init__(self, name):
        self.name = name
```

위 코드에서, `__init__`은 클래스를 사용한 객체의 초기화 메서드이다. 객체를 생성할 때 인자를 어떻게 전달받고, 받은 인자를 이용해 어떤 객체를 생성할 지 정의할 수 있다.

### 메서드

#### 인스턴스 메서드

인스턴스 메서드는 첫 번째 인수로 `self`를 가진다. 인스턴스를 이용해 메서드를 호출할 때 호출한 인스턴스가 자동으로 전달되며, 전달받은 인스턴스는 상태를 확인하거나 조작하는데에 사용된다.

### 속성 접근 지정자 (attribute access modifier)

#### 캡슐화

객체를 구현할 때, 사용자가 반드시 알아야 할 데이터나 메서드를 제외한 부분을 은닉시켜 정해진 방법을 통해서만 객체를 조작할 수 있도록 하는 방식.

```
_ protected
__ private
```

```
shop_type
>>> _shop_type or __shop_type
```

실제 이름은 \_<클래스명>__<속성명>으로 되어있다.

### get/set 속성값과 프로퍼티

파이썬에서는 지원하지 않지만, 어떤 언어들은 외부에서 접근할 수 없는 `private`객체 속성을 지원한다. 이 경우, 객체에서는 해당 속성을 읽고 쓰기 위해 `getter`, `setter`메서드를 사용해야 한다.

```python
@property
def name(self):
    return self.__name

@name.setter
def name(self, new_name):
    self.__name = new_name
    print('Set new name ({})'.format(self.__name))
```

`setter`프로퍼티를 명시하지 않으면 읽기전용이 되어 외부에서 조작할 수 없게 된다.

### 상속(Inheritance)

거의 비슷한 기능을 수행하나, 약간의 추가적인 기능이 필요한 다른 클래스가 필요할 경우 기존의 클래스를 상속받은 새 클래스를 사용하는 형태로 문제를 해결할 수 있다.

이 때, 상속 되는 클래스를 부모(상위)클래스라고 하며, 상속을 받는 클래스는 자식(하위)클래스라고 한다.

상속을 받을때는 클래스의 정의 다음 괄호에 부모 클래스를 적어주면 된다.

```
class Restaurant(Shop):
    pass
```

상속받은 클래스는 부모 클래스의 모든 속성과 메서드를 사용할 수 있다.

#### 메서드 오버라이드

상속받은 클래스에서, 부모 클래스의 메서드와는 다른 동작을 하도록 할 수 있다. 이 경우 부모 클래스의 메서드를 덮어씌워서 사용하도록 하며, 이 방법을 메서드 오버라이드(method override)라고 한다.

#### 부모 클래스의 메서드를 호출 (super)

자식클래스의 메서드에서 부모 클래스에서 사용하는 메서드의 전체를 새로 쓰는것이 아닌, 부모 클래스의 메서드를 호출 후 해당 내용으로 새로운 작업을 해야 할 경우 super()메서드를 사용해서 부모 클래스의 메서드를 직접 호출할 수 있다.

```
class Restaurant(Shop):
    def __init__(self, name, shop_type, address, rating):
        super().__init__(name, shop_type, address)
        self.rating = rating
```

위 코드의 경우, super()메서드를 사용해서 부모의 \_\_init__ 메서드를 호출한다.

#### 정적(스태틱) 메서드

스태틱 메서드는 클래스 내부에 정의된 일반 함수이며, 단지 클래스나 인스턴스를 통해서 접근할 수 있을 뿐 해당 클래스나 인스턴스에 영향을 주는 것은 불가능하다.

스태틱메서드는 `@staticmethod`데코레이터를 붙여 선언한다.

스태틱메서드는 다양한 방식으로 인스턴스를 생성하는 클래스를 작성할 때 자주 사용된다. `__init__()`초기화 함수는 하나만 존재할 수 있기 때문에, 다른 생성함수를 정적 메서드로 만들어 사용할 수 있다.

#### 클래스 메서드

클래스 메서드는 클래스 속성에 대해 동작하는 메서드이다. 위의 인스턴스 메서드와 달리 호출 주체가 클래스이며, 첫 번째 인자도 클래스이다.
만약 인스턴스가 첫 번째 인자로 주어지더라도 해당 인자의 클래스로 자동으로 바뀌어 전달된다.

클래스메서드는 `@classmethod`데코레이터를 붙여 선언하며, 첫 번째 인자의 이름은 관용적으로 `cls`를 사용한다.

클래스 메서드를 사용하면 부모 클래스를 상속받은 자식클래스에서 해당 부모클래스의 클래스 메서드를 사용할 경우, 자기 자신(자식)의 클래스를 사용할 수 있다.

```
@classmethod
def make_dummy(cls):
	return cls('untitled', 'undefined', 'unknown')
```

### 다형성 동적 바인딩

동적 바인딩은 타입을 신경 쓰지 않고 인스턴스를 사용할 수 있게 해주는 방식이다.

동적 바인딩은 속성 검색과정을 통해서 이루어진다. `obj.attr`을 통해 속성에 접근하면, 인스턴스에서 `attr`을, 다음엔 클래스에서, 그 다음에는 상속받은 클래스에서 해당 속성을 검색하며 가장 먼저 검색한 속성을 반환한다.

동적으로 속성을 바인딩하는 과정은 `obj`객체의 타입에 영향받지 않으며, 오로지 해당 객체가 attr에 해당하는 속성을 가졌는지만 검사한다.

이러한 작동방식은 '오리처럼 울고걸으면 그것은 오리이다'라는 말에서 유래한 `덕 타이핑(duck typing)`이라고 한다.

```
User, Sword, Shield클래스를 정의하고 속성을 동적으로 접근해본다.

User:
	- attrs
	name
	atk = 0
	def = 0

	- methods
	equip(item)
		item의 'use()'메서드를 사용
		이때 자기자신(인스턴스)를 전달
	
Sword, Shield:
	- methods
	use(user)
		user로 전달된 인스턴스의 특정 능력치를 높임
```
