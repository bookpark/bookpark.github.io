---
layout: post
comments: true
title: "Elastic Beanstalk"
categories: AWS
---

Elastic Beanstalk을 설정하며 중요한 부분을 정리해보았다.

---

### Elastic Beanstalk(EB)란?

[AWS Elastic Beanstalk란? (AWS Documentation)](http://docs.aws.amazon.com/ko_kr/elasticbeanstalk/latest/dg/Welcome.html)



### EB CLI 설치

```bash
pip install awsebcli
```



### EB CLI 구성

- Elastic Beanstalk의 FullAccess를 가질 user를 생성한다.
  - IAM 콘솔에서 유저 생성 후 credentials를 기존에 가지고 있던 credentials에 추가한다.
  - Permission에서 `AWSElasticBeanstalkFullAccess`를  추가한다.

```bash
## ~/.aws/credentials

# ec2_credentials
[default]
aws_access_key_id = ********************
aws_secret_access_key = ****************************************

# eb_credentials
[eb-user]
aws_access_key_id = ********************
aws_secret_access_key = ****************************************
```

- project_folder/ — *Elastic Beanstalk을 구성하기 위한 명령어들을 실행해준다*

 [EB CLI 구성 (AWS Documentation)](http://docs.aws.amazon.com/ko_kr/elasticbeanstalk/latest/dg/eb-cli3-configuration.html)

```bash
# eb init을 통해 기본 구성
eb init --profile eb-user

# init 설정 후 create을 통해 Elastic Beanstalk 생성
eb create --profile eb-user

# eb create 이후 Dockerfile이 준비 되었다면(Docker를 통해 개발하기 때문에) deploy 명령어로 배포
eb deploy
```



### Deploy를 위한 프로젝트 구성



**WSGI 모듈화**

기본 config 안에 있는 wsgi.py를 local, dev 환경에서 각각 다르게 동작하도록 모듈화 한다. 

- config/wsgi/_\_init__.py

```python
from .local import *
```

- config/wsgi/local.py

```python
import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "config.settings.local")

application = get_wsgi_application()
```

- config/wsgi/dev.py

```python
import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "config.settings.dev")

application = get_wsgi_application()
```



**.config 폴더 분리**

- `Nginx`, `uWSGI`, `supervisor`의 설정을 담고 있는 .config 폴더를 환경 별로 생성하고 경로를 변경해준다.

```bash
.config
├── dev
│   ├── nginx
│   │   ├── app.conf
│   │   └── nginx.conf
│   ├── supervisor
│   │   ├── supervisor-nginx.conf
│   │   └── supervisor-uwsgi.conf
│   └── uwsgi
│       └── app.ini
└── local
    ├── nginx
    │   ├── app.conf
    │   └── nginx.conf
    ├── supervisor
    │   ├── supervisor-nginx.conf
    │   └── supervisor-uwsgi.conf
    └── uwsgi
        └── app.ini
```



### EB SSH

- `eb ssh` 프로젝트 폴더 경로의 터미널에서 입력하게 되면 Elastic Beanstalk SSH로 접속할 수 있다.
  - 보통 이 안에서는 많은 것을 수정하지 않고 `로그`를 보는 용도로 사용하게 된다. `cd /var/log`


- sudo vi /etc/nginx/sites-available/elasticbeanstalk-nginx-docker-proxy.conf 
  - 위 파일에서 nginx 설정을 바꿔 줄 수 있다.

```nginx
# 아래 코드는 https redirect 하는 방법
location / {
  ...
  
  if ($http_x_forwarded_proto = 'http') {
    return 301 https://$host$request_uri;
  }
}
```

```nginx
# 아래 코드는 413 Request Entity Too Large 에러가 떴을 때
# Upload max size를 변경해준다
server {
  ...
    
  client_max_body_size 128M;
}
```

- nginx restart

```bash
sudo service nginx restart
```



> 위 방법으로 바꾸면 지금 당장은 적용이 가능하지만 EC2가 생성 될 때는 적용이 되지 않는다



### EB Extensions

- project/.ebextensions/*.config — *이 곳에 기본 설정을 넣어주게 되면 EC2 가 생성될 때마다 적용이 된다*

```yaml
files:
  "/etc/nginx/sites-available/elasticbeanstalk-nginx-docker-proxy.conf":
    mode: "000644"
    owner: root
    group: root
    content: |
      map $http_upgrade $connection_upgrade {
          default        "upgrade";
          ""            "";
      }

      server {
          listen 80;

          client_max_body_size 128M;

          gzip on;
              gzip_comp_level 4;
              gzip_types text/html text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;

          if ($time_iso8601 ~ "^(\d{4})-(\d{2})-(\d{2})T(\d{2})") {
              set $year $1;
              set $month $2;
              set $day $3;
              set $hour $4;
          }
          access_log /var/log/nginx/healthd/application.log.$year-$month-$day-$hour healthd;

          access_log    /var/log/nginx/access.log;

          location / {
              proxy_pass            http://docker;
              proxy_http_version    1.1;

              proxy_set_header    Connection            $connection_upgrade;
              proxy_set_header    Upgrade                $http_upgrade;
              proxy_set_header    Host                $host;
              proxy_set_header    X-Real-IP            $remote_addr;
              proxy_set_header    X-Forwarded-For        $proxy_add_x_forwarded_for;
          }

          if ($http_x_forwarded_proto = 'http') {
          return 301 https://$host$request_uri;
          }
      }

```

